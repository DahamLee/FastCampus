# day21 - 장고 기초(Models)

### Table name 변경 가능 - meta data에서

### Field 타입 만들 때 form 으로 만들었던 거처럼 default form을 만들어준다.

### Field 

**null** - 빈값도 없는 것
**blank** - 빈 값



<hr>
<hr>
## 장고 환경 설정

### 가상환경 삭제 하는 법 pyenv uninstall 환경명

### 장고 버전 관리

실행시 django_apps 동등 레벨 위치에서 
```pip freeze > requirements.txt```


### shell_plus 설치

shell_plus 설치: django_extensions 이용한다.

``` pip install django_extenstions ```

``` ./manage.py shell_plus ```

settings > INSTALLED_APPS 가서 'django\_extenstions' 추가

shell_plus 사용시 자동 import 가능

### ipython 설치

```pip install ipython```



<hr>
<hr>
# Relationship

## Many-to-one Relationship

``` ForeignKey를 통해서 연결이 된다. ```


### on_delete 뜻: 상위값이 삭제 될때:
**CASCADE : 위와 같이 삭제 된다**
**PROTECT : 하나라도 하위 값이 있으면 상위 클래스를 삭제 못하게 막는 기능**

### recursive relationship


### 코드 활용
* upper_class.objects.filter(###)
* upper_instance.'lowerclass'\_'set'.filter(###)

```
In [5]: Car.objects.filter(manufacturer=m).all()
Out[5]: <QuerySet [<Car: 520d>, <Car: 420d>, <Car: 320d>]>

In [6]: m.car_set.all()
Out[6]: <QuerySet [<Car: 520d>, <Car: 420d>, <Car: 320d>]>

In [7]: Car.objects
Out[7]: <django.db.models.manager.Manager at 0x106035828>

In [8]: m.car_set
Out[8]: <django.db.models.fields.related_descriptors.create_reverse_many_to_one_manager.<locals>.RelatedManager at 0x107289898>

```

```
In [17]: new_article = r.article_set.create(headline="John's second story", pub_date=date(2005,7,29))

In [18]: new_article
Out[18]: <Article: John's second story>

In [20]: new_article.reporter
Out[20]: <Reporter: John Smith>

In [21]: new_article.reporter.id
Out[21]: 1

```

## Many-to-many Relationship

`ManyToManyField 를 통해서 연결`

### Models 창

```
from django.db import models


class Topping(models.Model):
    name = models.CharField(max_length=30)

    def __str__(self):
        return self.name

    class Meta:
        ordering = ('name',)
        
        
class Pizza(models.Model):
    name = models.CharField(max_length=30)
    toppings = models.ManyToManyField(Topping)

    def __str__(self):
        return self.name

    class Meta:
        ordering = ('name',)

```

* 다대다 관계에서 pizza database와 toppings datebase 는 변함이 없고 중간에 pizza_toppings database가 하나 더 생겨서 중간에서 매개 역할을 해준다.


### Query 보는 방법 

```

In [23]: p_supersupreme.toppings.all()
Out[23]: <QuerySet [<Topping: cheeze>, <Topping: olive>, <Topping: tomato sauce>, <Topping: 햄>]>

In [24]: q = p_supersupreme.toppings.all()

In [25]: print(q.query)
SELECT "introduction_to_models_topping"."id", "introduction_to_models_topping"."name" FROM "introduction_to_models_topping" INNER JOIN "introduction_to_models_pizza_toppings" ON ("introduction_to_models_topping"."id" = "introduction_to_models_pizza_toppings"."topping_id") WHERE "introduction_to_models_pizza_toppings"."pizza_id" = 2 ORDER BY "introduction_to_models_topping"."name" ASC

```

```

In [26]: Pizza.objects.filter(toppings__id__lte=2)
Out[26]: <QuerySet [<Pizza: cheese_pizza>, <Pizza: supersupreme>, <Pizza: supersupreme>]>

In [27]: Pizza.objects.filter(toppings__id__lte=2).distinct()
Out[27]: <QuerySet [<Pizza: cheese_pizza>, <Pizza: supersupreme>]>

In [28]: Topping.objects.filter(pizza__name__startswith="chee")
Out[28]: <QuerySet [<Topping: cheeze>, <Topping: tomato sauce>]>

In [29]: Topping.objects.filter(pizza__name__startswith="chee").exclude(name="tomato")
Out[29]: <QuerySet [<Topping: cheeze>, <Topping: tomato sauce>]>

In [30]: Topping.objects.filter(pizza__name__startswith="chee").exclude(name="cheeze")
Out[30]: <QuerySet [<Topping: tomato sauce>]>

In [31]: Topping.objects.filter(pizza__name__startswith="chee").exclude(name="tomato sauce")


```

### Extra field on many-to-many relationship

>다대다 관계에서 extra field를 추가해서 두 field 간의 관계를 나타낼 수 있다.


> 이때 `through`를 이용한다.

> 이때는 extra field를 통해서만 둘 사이의 관계를 정의할 수 있다.

```
from django.db import models

class Person(models.Model):
    name = models.CharField(max_length=128)

    def __str__(self):              # __unicode__ on Python 2
        return self.name

class Group(models.Model):
    name = models.CharField(max_length=128)
    members = models.ManyToManyField(Person, through='Membership')

    def __str__(self):              # __unicode__ on Python 2
        return self.name

class Membership(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE)
    group = models.ForeignKey(Group, on_delete=models.CASCADE)
    date_joined = models.DateField()
    invite_reason = models.CharField(max_length=64)
    
```

## Tip


* If you need to create a relationship on a model that has not yet been defined, you can use the name of the model, rather than the model object itself

* 만약 아직 정의 되지 않은 관계클래스를 사용할거라면, 그 자체의 이름으로 사용하면 된다.

ex)


from django.db import models

class Car(models.Model):
    manufacturer = models.ForeignKey(
   
**'Manufacturer',**

   on_delete=models.CASCADE,
    )
    # ...

class Manufacturer(models.Model):
    # ...
    pass



